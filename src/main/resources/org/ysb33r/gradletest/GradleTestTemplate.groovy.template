package ${TESTPACKAGE}

import java.util.regex.Pattern
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.FileVisitResult
import java.nio.file.SimpleFileVisitor
import java.nio.file.FileAlreadyExistsException
import java.nio.file.attribute.BasicFileAttributes
import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING
import static java.nio.file.FileVisitResult.CONTINUE
import org.junit.Rule
import org.junit.rules.TemporaryFolder
import org.gradle.testkit.runner.GradleRunner
import org.gradle.util.GradleVersion
import org.gradle.testkit.runner.TaskOutcome
import spock.lang.Specification
import spock.lang.Unroll
import spock.lang.Title

@Title('${TESTNAME}')
class ${TESTNAME.replaceAll(/\W/,'_')}CompatibilitySpec extends Specification {

    static final String TESTBASENAME = '${TESTBASENAME}'
    static final String TESTFILENAME = '${TESTFILENAME}'
    static final String language = '${LANGUAGE}'

    static final File SOURCEDIR = new File('${SOURCEDIR}'.toURI())
    static final File CP_MANIFEST = new File('${MANIFEST}'.toURI())
    static final File WORKDIR = new File('${WORKDIR}'.toURI())
    static final boolean CHECK_WARNINGS = ${CHECK_WARNINGS}

    static final String DISTRIBUTION_URI = System.getProperty('org.ysb33r.gradletest.distribution.uri') ?: '${DISTRIBUTION_URI}'
    static final List<String> gradleArguments = [${ARGUMENTS}]
    static final List<Pattern> warnings = [
        ~/The .+ method has been deprecated and is scheduled to be removed in Gradle/,
        ~/Gradle now uses separate output directories for each JVM language, but this build assumes a single directory for all classes from a source set/
    ]

    static final String legacyStartsWith = 'buildscript { dependencies { classpath files('
    static List<File> pluginClasspath
    static String buildscriptClasspath

    File testProjectDir
    File buildFile
    GradleRunner gradleRunner

    void setupSpec() {
        if(!WORKDIR.exists()) {
            WORKDIR.mkdirs()
        }

        pluginClasspath = CP_MANIFEST.readLines().collect {
            new File(it)
        }

        buildscriptClasspath = legacyStartsWith +
            pluginClasspath.collect { "'" + it.absoluteFile.toURI().toString() + "'.toURI()" }.join(',') +
            ') } }' + "\\n\\n"
    }

    void setupForVersion(final String version) {
        final GradleVersion gradleVersionUnderTest = GradleVersion.version(version)
        testProjectDir = new File(WORKDIR,'${TESTBASENAME}/' + version)

        testProjectDir.mkdirs()
        Path source = SOURCEDIR.toPath()
        Path target = testProjectDir.toPath()

        def ant = new AntBuilder()
        ant.sequential {
            copy(todir: target) {
                fileset(dir: source) {
                    include(name: "**/*.*")
                }
            }
        }

        final File settings = new File(testProjectDir,'settings.gradle')
        if(!settings.exists()) {
            settings.text = ''
        }

        setupBuildScriptFile(testProjectDir, TESTFILENAME, language)

        final File deleteNotUsedDslScript = new File(testProjectDir,'${DELETE_SCRIPT}')
        deleteNotUsedDslScript.delete()

        gradleRunner = GradleRunner.create()
                       .withProjectDir(testProjectDir)
                       .forwardOutput()

       if( DISTRIBUTION_URI.empty ) {
           gradleRunner.withGradleVersion(version)
       } else {
           final String uri = DISTRIBUTION_URI + '/gradle-' + version + '-bin.zip'
           gradleRunner.withGradleDistribution(uri.toURI())
       }
       gradleRunner.withArguments(getArguments(gradleVersionUnderTest,version))
       addClasspath(gradleVersionUnderTest,version)
    }


    void setupBuildScriptFile(File testProjectDir, String testScriptName, String lang){
        String buildFile
        String stagedBuildFile

        (buildFile, stagedBuildFile) = getScriptFilenames(lang)

        if (testScriptName == buildFile) {
            testScriptName = stagedBuildFile
        }

        File build = new File(testProjectDir, buildFile)
        File staged = new File(testProjectDir, stagedBuildFile)

        if (build.exists() && staged.exists()) {
            // this means that this script has created a staged build file in the past
            // therefore the data in the staged build is the actual build file and the
            // build file is actually the thin wrapper
            build.delete()
        } else if (build.exists() && !staged.exists()) {
            // here we can assume that this has never been run on the folder
            // and the build script is the actual build script
            build.renameTo(staged)
        }

        switch (lang) {
            case 'LANGUAGE.GROOVY':
                build.write("apply from: '" + testScriptName + "'")
                break
            case 'LANGUAGE.KOTLIN':
                build.write("apply { from('" + testScriptName + "') }")
                break
        }

    }

    def getScriptFilenames(String lang) {
        switch (lang) {
        case 'LANGUAGE.GROOVY':
            return ["build.gradle", "staged.build.gradle"]
        case 'LANGUAGE.KOTLIN':
            return ["build.gradle.kts", "staged.build.gradle.kts"]
        }
    }

    List<String> getArguments(final GradleVersion gradleVersionUnderTest,final String version) {
        List<String> args = gradleArguments + []
        args.add( (gradleVersionUnderTest > GradleVersion.version('2.2')) ? '--console=plain' : '--no-color')
        args
    }

    void addClasspath(final GradleVersion gradleVersionUnderTest,final String version) {
        if( gradleVersionUnderTest >= GradleVersion.version('2.8') ) {
            gradleRunner.withPluginClasspath(pluginClasspath)
        } else {
            addClassHeader('build.gradle')
            addClassHeader('staged.build.gradle')
        }
    }

    void addClassHeader(String filename) {
        File buildScript = new File(testProjectDir,filename)
        if (buildScript.exists()){
            if (!buildScript.text.startsWith(legacyStartsWith)) {
                String newScript = buildscriptClasspath.replaceAll(/1.0-groovy-2.4/,'1.0-groovy-2.3') + buildScript.text
                buildScript.text = newScript
            }
        }
    }

    @Unroll
    def "${TESTNAME} : #version"() {
        setup:
        final GradleVersion gradleVersionUnderTest = GradleVersion.version(version)
        setupForVersion(version)

        when:
        println 'The build is using Gradle ' + GradleVersion.current() + ' and this test project will now use Gradle ' + version
        def result = gradleRunner.${FAILMODE?'buildAndFail':'build'}()

        then:
        if(gradleVersionUnderTest >= GradleVersion.version('2.5')) {
            result.task(':${DEFAULTTASK}')?.outcome == TaskOutcome.${FAILMODE?'FAILED':'SUCCESS'}
        } else {
            pre25_checkoutcome(${FAILMODE},result.output)
        }
        no_deprecation_warnings(result.output)

        where:
        version << [${VERSIONS}]
    }

    private boolean no_deprecation_warnings(final String output) {
        if(!CHECK_WARNINGS) {
            true
        } else {
            !warnings.any { pat ->
                output =~ pat
            }
        }
    }

    private boolean pre25_checkoutcome(boolean is_failmode,def output) {
        if(is_failmode) {
            output.matches(':${DEFAULTTASK} FAILED')
        } else {
            !output.matches(':${DEFAULTTASK} (SKIPPED|UP-TO-DATE|FAILED)')
        }
    }
}
